open(file, mode='rt', encoding=None) -> BaseIO
mode参数详解：
字符         含意
'r'         读取（默认）
'w'         写入，并先截断文件
'a'         打开文件用于写入，如果文件存在则在末尾追加

'b'         二进制模式
't'         文本模式（默认）

'+'         打开用于更新（读取与写入）


细节问题：
（1）文件操作过程全程存在文件指针，不管读取还是写入都存在指针的移动
（2）文件指针初始值指向0的位置，其移动单位为字节(bytes)
（3）open函数返回的是文本流对象，假设为f
        --- f.read(size=-1)   #即默认读取整个文本
            size表示至多读取size个字符或字节，然后将指针移动到下一个字节；
            以"t"的形式打开，size的单位是字符(注意: gbk编码的汉字1字符==2字节，utf8的1字符==3字节)
            以"b"的形式打开，size的单位是字节
            eg. len("我".encode('gbk')) => 2
                len("我".encode('utf8')) => 3
        f.write(s) #写入字符串s，并将指针移动到s最后内容的下一个字节
        f.readline()  # 读取内容至换行符\n，并将指针移动到下一行开始的位置
        f.readlines() #每一行(包括行尾的换行符\n)作为列表的一个元素，返回列表
        如果想要迭代每一行(包含\n)，可以利用for line in f: 来迭代，从而避免占用过多内存


（4）'r'和'w'的方式读取，指针初始为0，且'w'的方式会删掉该文件所有内容；
    'a'的方式读取指针指向源文件内容的下一个字节;
    'a'和'w'可以自动创建一个不存在文件文件，'r'不行
（5）'+'用于就地修改文件
（6）常用组合
    'r+'   #可读取、可写入文件; 文件指针为0
    'w+'   #可读取、可写入文件；文件指针为0，并删除原文件所有内容
    'a+'   #可读取、可写入文件；文件指针在文章末尾

    'rb'
    'rb+'
    'wb'
    'wb+'
    'ab'
    ...

(7)操作文件指针的函数(单位均为字节)
    f.tell() #返回指针指向的位置c
    f.seek(offset, whence=SEEK_SET)
        SEEK_SET 或 0 -- 流的开头（默认值）
        SEEK_CUR or 1 -- 当前流位置；
        SEEK_END or 2 -- 流的末尾；
    f.truncate(size) #文件从头开始仅保留size个字节

    eg: seek和truncate通常用在对原文件就地更新
        with open('xx.txt', 'r+', encoding='utf8') as f:
            content = f.read()
            f.truncate(0)  #等价于将原文件内容全部删除
            f.seek(0)   #由于此时指针还在文章末尾，所以需要将指针位置归零



